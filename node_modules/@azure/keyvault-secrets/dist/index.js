/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure KeyVault Secrets SDK for JavaScript - 4.0.2
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
require('@azure/core-paging');
var coreLro = require('@azure/core-lro');
var url = require('url');

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
var logger = logger$1.createClientLogger("keyvault-secrets");

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var Attributes = {
    serializedName: "Attributes",
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var JsonWebKey = {
    serializedName: "JsonWebKey",
    type: {
        name: "Composite",
        className: "JsonWebKey",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            n: {
                serializedName: "n",
                type: {
                    name: "Base64Url"
                }
            },
            e: {
                serializedName: "e",
                type: {
                    name: "Base64Url"
                }
            },
            d: {
                serializedName: "d",
                type: {
                    name: "Base64Url"
                }
            },
            dp: {
                serializedName: "dp",
                type: {
                    name: "Base64Url"
                }
            },
            dq: {
                serializedName: "dq",
                type: {
                    name: "Base64Url"
                }
            },
            qi: {
                serializedName: "qi",
                type: {
                    name: "Base64Url"
                }
            },
            p: {
                serializedName: "p",
                type: {
                    name: "Base64Url"
                }
            },
            q: {
                serializedName: "q",
                type: {
                    name: "Base64Url"
                }
            },
            k: {
                serializedName: "k",
                type: {
                    name: "Base64Url"
                }
            },
            t: {
                serializedName: "key_hsm",
                type: {
                    name: "Base64Url"
                }
            },
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "Base64Url"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyAttributes = {
    serializedName: "KeyAttributes",
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var KeyBundle = {
    serializedName: "KeyBundle",
    type: {
        name: "Composite",
        className: "KeyBundle",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyItem = {
    serializedName: "KeyItem",
    type: {
        name: "Composite",
        className: "KeyItem",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedKeyBundle = {
    serializedName: "DeletedKeyBundle",
    type: {
        name: "Composite",
        className: "DeletedKeyBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, KeyBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedKeyItem = {
    serializedName: "DeletedKeyItem",
    type: {
        name: "Composite",
        className: "DeletedKeyItem",
        modelProperties: tslib.__assign(tslib.__assign({}, KeyItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretAttributes = {
    serializedName: "SecretAttributes",
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var SecretBundle = {
    serializedName: "SecretBundle",
    type: {
        name: "Composite",
        className: "SecretBundle",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var SecretItem = {
    serializedName: "SecretItem",
    type: {
        name: "Composite",
        className: "SecretItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            managed: {
                readOnly: true,
                serializedName: "managed",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var DeletedSecretBundle = {
    serializedName: "DeletedSecretBundle",
    type: {
        name: "Composite",
        className: "DeletedSecretBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, SecretBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedSecretItem = {
    serializedName: "DeletedSecretItem",
    type: {
        name: "Composite",
        className: "DeletedSecretItem",
        modelProperties: tslib.__assign(tslib.__assign({}, SecretItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SecretRestoreParameters = {
    serializedName: "SecretRestoreParameters",
    type: {
        name: "Composite",
        className: "SecretRestoreParameters",
        modelProperties: {
            secretBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var StorageRestoreParameters = {
    serializedName: "StorageRestoreParameters",
    type: {
        name: "Composite",
        className: "StorageRestoreParameters",
        modelProperties: {
            storageBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateAttributes = {
    serializedName: "CertificateAttributes",
    type: {
        name: "Composite",
        className: "CertificateAttributes",
        modelProperties: tslib.__assign(tslib.__assign({}, Attributes.type.modelProperties), { recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            } })
    }
};
var CertificateItem = {
    serializedName: "CertificateItem",
    type: {
        name: "Composite",
        className: "CertificateItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            x509Thumbprint: {
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var CertificateIssuerItem = {
    serializedName: "CertificateIssuerItem",
    type: {
        name: "Composite",
        className: "CertificateIssuerItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyProperties = {
    serializedName: "KeyProperties",
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            },
            keyType: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            reuseKey: {
                serializedName: "reuse_key",
                type: {
                    name: "Boolean"
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretProperties = {
    serializedName: "SecretProperties",
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SubjectAlternativeNames = {
    serializedName: "SubjectAlternativeNames",
    type: {
        name: "Composite",
        className: "SubjectAlternativeNames",
        modelProperties: {
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsNames: {
                serializedName: "dns_names",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            upns: {
                serializedName: "upns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var X509CertificateProperties = {
    serializedName: "X509CertificateProperties",
    type: {
        name: "Composite",
        className: "X509CertificateProperties",
        modelProperties: {
            subject: {
                serializedName: "subject",
                type: {
                    name: "String"
                }
            },
            ekus: {
                serializedName: "ekus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subjectAlternativeNames: {
                serializedName: "sans",
                type: {
                    name: "Composite",
                    className: "SubjectAlternativeNames"
                }
            },
            keyUsage: {
                serializedName: "key_usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            validityInMonths: {
                serializedName: "validity_months",
                constraints: {
                    InclusiveMinimum: 0
                },
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Trigger = {
    serializedName: "Trigger",
    type: {
        name: "Composite",
        className: "Trigger",
        modelProperties: {
            lifetimePercentage: {
                serializedName: "lifetime_percentage",
                constraints: {
                    InclusiveMaximum: 99,
                    InclusiveMinimum: 1
                },
                type: {
                    name: "Number"
                }
            },
            daysBeforeExpiry: {
                serializedName: "days_before_expiry",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
var Action = {
    serializedName: "Action",
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            actionType: {
                serializedName: "action_type",
                type: {
                    name: "Enum",
                    allowedValues: ["EmailContacts", "AutoRenew"]
                }
            }
        }
    }
};
var LifetimeAction = {
    serializedName: "LifetimeAction",
    type: {
        name: "Composite",
        className: "LifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "Trigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "Action"
                }
            }
        }
    }
};
var IssuerParameters = {
    serializedName: "IssuerParameters",
    type: {
        name: "Composite",
        className: "IssuerParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            certificateType: {
                serializedName: "cty",
                type: {
                    name: "String"
                }
            },
            certificateTransparency: {
                serializedName: "cert_transparency",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var CertificatePolicy = {
    serializedName: "CertificatePolicy",
    type: {
        name: "Composite",
        className: "CertificatePolicy",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            keyProperties: {
                serializedName: "key_props",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            },
            secretProperties: {
                serializedName: "secret_props",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            },
            x509CertificateProperties: {
                serializedName: "x509_props",
                type: {
                    name: "Composite",
                    className: "X509CertificateProperties"
                }
            },
            lifetimeActions: {
                serializedName: "lifetime_actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LifetimeAction"
                        }
                    }
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            }
        }
    }
};
var CertificateBundle = {
    serializedName: "CertificateBundle",
    type: {
        name: "Composite",
        className: "CertificateBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            sid: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            x509Thumbprint: {
                readOnly: true,
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            },
            policy: {
                readOnly: true,
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            cer: {
                serializedName: "cer",
                type: {
                    name: "ByteArray"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedCertificateBundle = {
    serializedName: "DeletedCertificateBundle",
    type: {
        name: "Composite",
        className: "DeletedCertificateBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, CertificateBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var DeletedCertificateItem = {
    serializedName: "DeletedCertificateItem",
    type: {
        name: "Composite",
        className: "DeletedCertificateItem",
        modelProperties: tslib.__assign(tslib.__assign({}, CertificateItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                readOnly: true,
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                readOnly: true,
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            innerError: {
                readOnly: true,
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateOperation = {
    serializedName: "CertificateOperation",
    type: {
        name: "Composite",
        className: "CertificateOperation",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            csr: {
                serializedName: "csr",
                type: {
                    name: "ByteArray"
                }
            },
            cancellationRequested: {
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDetails: {
                serializedName: "status_details",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request_id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var IssuerCredentials = {
    serializedName: "IssuerCredentials",
    type: {
        name: "Composite",
        className: "IssuerCredentials",
        modelProperties: {
            accountId: {
                serializedName: "account_id",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var AdministratorDetails = {
    serializedName: "AdministratorDetails",
    type: {
        name: "Composite",
        className: "AdministratorDetails",
        modelProperties: {
            firstName: {
                serializedName: "first_name",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "last_name",
                type: {
                    name: "String"
                }
            },
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var OrganizationDetails = {
    serializedName: "OrganizationDetails",
    type: {
        name: "Composite",
        className: "OrganizationDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            adminDetails: {
                serializedName: "admin_details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdministratorDetails"
                        }
                    }
                }
            }
        }
    }
};
var IssuerAttributes = {
    serializedName: "IssuerAttributes",
    type: {
        name: "Composite",
        className: "IssuerAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
var IssuerBundle = {
    serializedName: "IssuerBundle",
    type: {
        name: "Composite",
        className: "IssuerBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var Contact = {
    serializedName: "Contact",
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var Contacts = {
    serializedName: "Contacts",
    type: {
        name: "Composite",
        className: "Contacts",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            contactList: {
                serializedName: "contacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Contact"
                        }
                    }
                }
            }
        }
    }
};
var KeyCreateParameters = {
    serializedName: "KeyCreateParameters",
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            kty: {
                required: true,
                serializedName: "kty",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var KeyImportParameters = {
    serializedName: "KeyImportParameters",
    type: {
        name: "Composite",
        className: "KeyImportParameters",
        modelProperties: {
            hsm: {
                serializedName: "Hsm",
                type: {
                    name: "Boolean"
                }
            },
            key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "JsonWebKey"
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyOperationsParameters = {
    serializedName: "KeyOperationsParameters",
    type: {
        name: "Composite",
        className: "KeyOperationsParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeySignParameters = {
    serializedName: "KeySignParameters",
    type: {
        name: "Composite",
        className: "KeySignParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyParameters = {
    serializedName: "KeyVerifyParameters",
    type: {
        name: "Composite",
        className: "KeyVerifyParameters",
        modelProperties: {
            algorithm: {
                required: true,
                serializedName: "alg",
                constraints: {
                    MinLength: 1
                },
                type: {
                    name: "String"
                }
            },
            digest: {
                required: true,
                serializedName: "digest",
                type: {
                    name: "Base64Url"
                }
            },
            signature: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyUpdateParameters = {
    serializedName: "KeyUpdateParameters",
    type: {
        name: "Composite",
        className: "KeyUpdateParameters",
        modelProperties: {
            keyOps: {
                serializedName: "key_ops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keyAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyRestoreParameters = {
    serializedName: "KeyRestoreParameters",
    type: {
        name: "Composite",
        className: "KeyRestoreParameters",
        modelProperties: {
            keyBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var SecretSetParameters = {
    serializedName: "SecretSetParameters",
    type: {
        name: "Composite",
        className: "SecretSetParameters",
        modelProperties: {
            value: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
var SecretUpdateParameters = {
    serializedName: "SecretUpdateParameters",
    type: {
        name: "Composite",
        className: "SecretUpdateParameters",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            secretAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateCreateParameters = {
    serializedName: "CertificateCreateParameters",
    type: {
        name: "Composite",
        className: "CertificateCreateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateImportParameters = {
    serializedName: "CertificateImportParameters",
    type: {
        name: "Composite",
        className: "CertificateImportParameters",
        modelProperties: {
            base64EncodedCertificate: {
                required: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            },
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateUpdateParameters = {
    serializedName: "CertificateUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateUpdateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateMergeParameters = {
    serializedName: "CertificateMergeParameters",
    type: {
        name: "Composite",
        className: "CertificateMergeParameters",
        modelProperties: {
            x509Certificates: {
                required: true,
                serializedName: "x5c",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var CertificateIssuerSetParameters = {
    serializedName: "CertificateIssuerSetParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerSetParameters",
        modelProperties: {
            provider: {
                required: true,
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateIssuerUpdateParameters = {
    serializedName: "CertificateIssuerUpdateParameters",
    type: {
        name: "Composite",
        className: "CertificateIssuerUpdateParameters",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
var CertificateOperationUpdateParameter = {
    serializedName: "CertificateOperationUpdateParameter",
    type: {
        name: "Composite",
        className: "CertificateOperationUpdateParameter",
        modelProperties: {
            cancellationRequested: {
                required: true,
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyOperationResult = {
    serializedName: "KeyOperationResult",
    type: {
        name: "Composite",
        className: "KeyOperationResult",
        modelProperties: {
            kid: {
                readOnly: true,
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            result: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var KeyVerifyResult = {
    serializedName: "KeyVerifyResult",
    type: {
        name: "Composite",
        className: "KeyVerifyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
var KeyListResult = {
    serializedName: "KeyListResult",
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedKeyListResult = {
    serializedName: "DeletedKeyListResult",
    type: {
        name: "Composite",
        className: "DeletedKeyListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedKeyItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SecretListResult = {
    serializedName: "SecretListResult",
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSecretListResult = {
    serializedName: "DeletedSecretListResult",
    type: {
        name: "Composite",
        className: "DeletedSecretListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSecretItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateListResult = {
    serializedName: "CertificateListResult",
    type: {
        name: "Composite",
        className: "CertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedCertificateListResult = {
    serializedName: "DeletedCertificateListResult",
    type: {
        name: "Composite",
        className: "DeletedCertificateListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedCertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var CertificateIssuerListResult = {
    serializedName: "CertificateIssuerListResult",
    type: {
        name: "Composite",
        className: "CertificateIssuerListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateIssuerItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var BackupKeyResult = {
    serializedName: "BackupKeyResult",
    type: {
        name: "Composite",
        className: "BackupKeyResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupSecretResult = {
    serializedName: "BackupSecretResult",
    type: {
        name: "Composite",
        className: "BackupSecretResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupStorageResult = {
    serializedName: "BackupStorageResult",
    type: {
        name: "Composite",
        className: "BackupStorageResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var PendingCertificateSigningRequestResult = {
    serializedName: "PendingCertificateSigningRequestResult",
    type: {
        name: "Composite",
        className: "PendingCertificateSigningRequestResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountAttributes = {
    serializedName: "StorageAccountAttributes",
    type: {
        name: "Composite",
        className: "StorageAccountAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageBundle = {
    serializedName: "StorageBundle",
    type: {
        name: "Composite",
        className: "StorageBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                readOnly: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                readOnly: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                readOnly: true,
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageBundle = {
    serializedName: "DeletedStorageBundle",
    type: {
        name: "Composite",
        className: "DeletedStorageBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, StorageBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var StorageAccountCreateParameters = {
    serializedName: "StorageAccountCreateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountCreateParameters",
        modelProperties: {
            resourceId: {
                required: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            activeKeyName: {
                required: true,
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                required: true,
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountUpdateParameters = {
    serializedName: "StorageAccountUpdateParameters",
    type: {
        name: "Composite",
        className: "StorageAccountUpdateParameters",
        modelProperties: {
            activeKeyName: {
                serializedName: "activeKeyName",
                type: {
                    name: "String"
                }
            },
            autoRegenerateKey: {
                serializedName: "autoRegenerateKey",
                type: {
                    name: "Boolean"
                }
            },
            regenerationPeriod: {
                serializedName: "regenerationPeriod",
                type: {
                    name: "String"
                }
            },
            storageAccountAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var StorageAccountRegenerteKeyParameters = {
    serializedName: "StorageAccountRegenerteKeyParameters",
    type: {
        name: "Composite",
        className: "StorageAccountRegenerteKeyParameters",
        modelProperties: {
            keyName: {
                required: true,
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var StorageAccountItem = {
    serializedName: "StorageAccountItem",
    type: {
        name: "Composite",
        className: "StorageAccountItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                readOnly: true,
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "StorageAccountAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedStorageAccountItem = {
    serializedName: "DeletedStorageAccountItem",
    type: {
        name: "Composite",
        className: "DeletedStorageAccountItem",
        modelProperties: tslib.__assign(tslib.__assign({}, StorageAccountItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var StorageListResult = {
    serializedName: "StorageListResult",
    type: {
        name: "Composite",
        className: "StorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedStorageListResult = {
    serializedName: "DeletedStorageListResult",
    type: {
        name: "Composite",
        className: "DeletedStorageListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedStorageAccountItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionAttributes = {
    serializedName: "SasDefinitionAttributes",
    type: {
        name: "Composite",
        className: "SasDefinitionAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                readOnly: true,
                serializedName: "created",
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                readOnly: true,
                serializedName: "updated",
                type: {
                    name: "UnixTime"
                }
            },
            recoveryLevel: {
                nullable: false,
                readOnly: true,
                serializedName: "recoveryLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionBundle = {
    serializedName: "SasDefinitionBundle",
    type: {
        name: "Composite",
        className: "SasDefinitionBundle",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            templateUri: {
                readOnly: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                readOnly: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                readOnly: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionBundle = {
    serializedName: "DeletedSasDefinitionBundle",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionBundle",
        modelProperties: tslib.__assign(tslib.__assign({}, SasDefinitionBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionItem = {
    serializedName: "SasDefinitionItem",
    type: {
        name: "Composite",
        className: "SasDefinitionItem",
        modelProperties: {
            id: {
                readOnly: true,
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            secretId: {
                readOnly: true,
                serializedName: "sid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                readOnly: true,
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                readOnly: true,
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var DeletedSasDefinitionItem = {
    serializedName: "DeletedSasDefinitionItem",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionItem",
        modelProperties: tslib.__assign(tslib.__assign({}, SasDefinitionItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                readOnly: true,
                serializedName: "scheduledPurgeDate",
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                readOnly: true,
                serializedName: "deletedDate",
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
var SasDefinitionListResult = {
    serializedName: "SasDefinitionListResult",
    type: {
        name: "Composite",
        className: "SasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var DeletedSasDefinitionListResult = {
    serializedName: "DeletedSasDefinitionListResult",
    type: {
        name: "Composite",
        className: "DeletedSasDefinitionListResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedSasDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                readOnly: true,
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
var SasDefinitionCreateParameters = {
    serializedName: "SasDefinitionCreateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionCreateParameters",
        modelProperties: {
            templateUri: {
                required: true,
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                required: true,
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                required: true,
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var SasDefinitionUpdateParameters = {
    serializedName: "SasDefinitionUpdateParameters",
    type: {
        name: "Composite",
        className: "SasDefinitionUpdateParameters",
        modelProperties: {
            templateUri: {
                serializedName: "templateUri",
                type: {
                    name: "String"
                }
            },
            sasType: {
                serializedName: "sasType",
                type: {
                    name: "String"
                }
            },
            validityPeriod: {
                serializedName: "validityPeriod",
                type: {
                    name: "String"
                }
            },
            sasDefinitionAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SasDefinitionAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
var KeyVaultError = {
    serializedName: "KeyVaultError",
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                readOnly: true,
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
var CertificateRestoreParameters = {
    serializedName: "CertificateRestoreParameters",
    type: {
        name: "Composite",
        className: "CertificateRestoreParameters",
        modelProperties: {
            certificateBundleBackup: {
                required: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
var BackupCertificateResult = {
    serializedName: "BackupCertificateResult",
    type: {
        name: "Composite",
        className: "BackupCertificateResult",
        modelProperties: {
            value: {
                readOnly: true,
                serializedName: "value",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Attributes: Attributes,
    JsonWebKey: JsonWebKey,
    KeyAttributes: KeyAttributes,
    KeyBundle: KeyBundle,
    KeyItem: KeyItem,
    DeletedKeyBundle: DeletedKeyBundle,
    DeletedKeyItem: DeletedKeyItem,
    SecretAttributes: SecretAttributes,
    SecretBundle: SecretBundle,
    SecretItem: SecretItem,
    DeletedSecretBundle: DeletedSecretBundle,
    DeletedSecretItem: DeletedSecretItem,
    SecretRestoreParameters: SecretRestoreParameters,
    StorageRestoreParameters: StorageRestoreParameters,
    CertificateAttributes: CertificateAttributes,
    CertificateItem: CertificateItem,
    CertificateIssuerItem: CertificateIssuerItem,
    KeyProperties: KeyProperties,
    SecretProperties: SecretProperties,
    SubjectAlternativeNames: SubjectAlternativeNames,
    X509CertificateProperties: X509CertificateProperties,
    Trigger: Trigger,
    Action: Action,
    LifetimeAction: LifetimeAction,
    IssuerParameters: IssuerParameters,
    CertificatePolicy: CertificatePolicy,
    CertificateBundle: CertificateBundle,
    DeletedCertificateBundle: DeletedCertificateBundle,
    DeletedCertificateItem: DeletedCertificateItem,
    ErrorModel: ErrorModel,
    CertificateOperation: CertificateOperation,
    IssuerCredentials: IssuerCredentials,
    AdministratorDetails: AdministratorDetails,
    OrganizationDetails: OrganizationDetails,
    IssuerAttributes: IssuerAttributes,
    IssuerBundle: IssuerBundle,
    Contact: Contact,
    Contacts: Contacts,
    KeyCreateParameters: KeyCreateParameters,
    KeyImportParameters: KeyImportParameters,
    KeyOperationsParameters: KeyOperationsParameters,
    KeySignParameters: KeySignParameters,
    KeyVerifyParameters: KeyVerifyParameters,
    KeyUpdateParameters: KeyUpdateParameters,
    KeyRestoreParameters: KeyRestoreParameters,
    SecretSetParameters: SecretSetParameters,
    SecretUpdateParameters: SecretUpdateParameters,
    CertificateCreateParameters: CertificateCreateParameters,
    CertificateImportParameters: CertificateImportParameters,
    CertificateUpdateParameters: CertificateUpdateParameters,
    CertificateMergeParameters: CertificateMergeParameters,
    CertificateIssuerSetParameters: CertificateIssuerSetParameters,
    CertificateIssuerUpdateParameters: CertificateIssuerUpdateParameters,
    CertificateOperationUpdateParameter: CertificateOperationUpdateParameter,
    KeyOperationResult: KeyOperationResult,
    KeyVerifyResult: KeyVerifyResult,
    KeyListResult: KeyListResult,
    DeletedKeyListResult: DeletedKeyListResult,
    SecretListResult: SecretListResult,
    DeletedSecretListResult: DeletedSecretListResult,
    CertificateListResult: CertificateListResult,
    DeletedCertificateListResult: DeletedCertificateListResult,
    CertificateIssuerListResult: CertificateIssuerListResult,
    BackupKeyResult: BackupKeyResult,
    BackupSecretResult: BackupSecretResult,
    BackupStorageResult: BackupStorageResult,
    PendingCertificateSigningRequestResult: PendingCertificateSigningRequestResult,
    StorageAccountAttributes: StorageAccountAttributes,
    StorageBundle: StorageBundle,
    DeletedStorageBundle: DeletedStorageBundle,
    StorageAccountCreateParameters: StorageAccountCreateParameters,
    StorageAccountUpdateParameters: StorageAccountUpdateParameters,
    StorageAccountRegenerteKeyParameters: StorageAccountRegenerteKeyParameters,
    StorageAccountItem: StorageAccountItem,
    DeletedStorageAccountItem: DeletedStorageAccountItem,
    StorageListResult: StorageListResult,
    DeletedStorageListResult: DeletedStorageListResult,
    SasDefinitionAttributes: SasDefinitionAttributes,
    SasDefinitionBundle: SasDefinitionBundle,
    DeletedSasDefinitionBundle: DeletedSasDefinitionBundle,
    SasDefinitionItem: SasDefinitionItem,
    DeletedSasDefinitionItem: DeletedSasDefinitionItem,
    SasDefinitionListResult: SasDefinitionListResult,
    DeletedSasDefinitionListResult: DeletedSasDefinitionListResult,
    SasDefinitionCreateParameters: SasDefinitionCreateParameters,
    SasDefinitionUpdateParameters: SasDefinitionUpdateParameters,
    KeyVaultError: KeyVaultError,
    CertificateRestoreParameters: CertificateRestoreParameters,
    BackupCertificateResult: BackupCertificateResult
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
var certificateName0 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        type: {
            name: "String"
        }
    }
};
var certificateName1 = {
    parameterPath: "certificateName",
    mapper: {
        required: true,
        serializedName: "certificate-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var certificateVersion = {
    parameterPath: "certificateVersion",
    mapper: {
        required: true,
        serializedName: "certificate-version",
        type: {
            name: "String"
        }
    }
};
var includePending = {
    parameterPath: ["options", "includePending"],
    mapper: {
        serializedName: "includePending",
        type: {
            name: "Boolean"
        }
    }
};
var issuerName = {
    parameterPath: "issuerName",
    mapper: {
        required: true,
        serializedName: "issuer-name",
        type: {
            name: "String"
        }
    }
};
var keyName0 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var keyName1 = {
    parameterPath: "keyName",
    mapper: {
        required: true,
        serializedName: "key-name",
        type: {
            name: "String"
        }
    }
};
var keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        required: true,
        serializedName: "key-version",
        type: {
            name: "String"
        }
    }
};
var maxresults = {
    parameterPath: ["options", "maxresults"],
    mapper: {
        serializedName: "maxresults",
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        type: {
            name: "Number"
        }
    }
};
var sasDefinitionName = {
    parameterPath: "sasDefinitionName",
    mapper: {
        required: true,
        serializedName: "sas-definition-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName0 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z-]+$/
        },
        type: {
            name: "String"
        }
    }
};
var secretName1 = {
    parameterPath: "secretName",
    mapper: {
        required: true,
        serializedName: "secret-name",
        type: {
            name: "String"
        }
    }
};
var secretVersion = {
    parameterPath: "secretVersion",
    mapper: {
        required: true,
        serializedName: "secret-version",
        type: {
            name: "String"
        }
    }
};
var storageAccountName0 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        constraints: {
            Pattern: /^[0-9a-zA-Z]+$/
        },
        type: {
            name: "String"
        }
    }
};
var storageAccountName1 = {
    parameterPath: "storageAccountName",
    mapper: {
        required: true,
        serializedName: "storage-account-name",
        type: {
            name: "String"
        }
    }
};
var vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        required: true,
        serializedName: "vaultBaseUrl",
        defaultValue: "",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var packageName = "@azure/keyvault-secrets";
var packageVersion = "4.0.2";
var KeyVaultClientContext = /** @class */ (function (_super) {
    tslib.__extends(KeyVaultClientContext, _super);
    /**
     * Initializes a new instance of the KeyVaultClientContext class.
     * @param apiVersion Client API version.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    function KeyVaultClientContext(credentials, apiVersion, options) {
        var _this = this;
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (credentials == undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            var defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = packageName + "/" + packageVersion + " " + defaultUserAgent;
        }
        _this = _super.call(this, credentials, options) || this;
        _this.baseUri = "{vaultBaseUrl}";
        _this.requestContentType = "application/json; charset=utf-8";
        _this.apiVersion = apiVersion;
        _this.credentials = credentials;
        return _this;
    }
    return KeyVaultClientContext;
}(coreHttp.ServiceClient));

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
var KeyVaultClient = /** @class */ (function (_super) {
    tslib.__extends(KeyVaultClient, _super);
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param apiVersion Client API version.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    function KeyVaultClient(credentials, apiVersion, options) {
        return _super.call(this, credentials, apiVersion, options) || this;
    }
    KeyVaultClient.prototype.createKey = function (vaultBaseUrl, keyName, kty, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            kty: kty,
            options: options
        }, createKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.importKey = function (vaultBaseUrl, keyName, key, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            key: key,
            options: options
        }, importKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, deleteKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, updateKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKey = function (vaultBaseUrl, keyName, keyVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            options: options
        }, getKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeyVersions = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getKeyVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, backupKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreKey = function (vaultBaseUrl, keyBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyBundleBackup: keyBundleBackup,
            options: options
        }, restoreKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.encrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, encryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.decrypt = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, decryptOperationSpec, callback);
    };
    KeyVaultClient.prototype.sign = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, signOperationSpec, callback);
    };
    KeyVaultClient.prototype.verify = function (vaultBaseUrl, keyName, keyVersion, algorithm, digest, signature, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            digest: digest,
            signature: signature,
            options: options
        }, verifyOperationSpec, callback);
    };
    KeyVaultClient.prototype.wrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, wrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.unwrapKey = function (vaultBaseUrl, keyName, keyVersion, algorithm, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            keyVersion: keyVersion,
            algorithm: algorithm,
            value: value,
            options: options
        }, unwrapKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKeys = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedKeysOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, getDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, purgeDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedKey = function (vaultBaseUrl, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            keyName: keyName,
            options: options
        }, recoverDeletedKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSecret = function (vaultBaseUrl, secretName, value, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            value: value,
            options: options
        }, setSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, deleteSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, updateSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecret = function (vaultBaseUrl, secretName, secretVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            secretVersion: secretVersion,
            options: options
        }, getSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSecretVersions = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getSecretVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecrets = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedSecretsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, getDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, purgeDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, recoverDeletedSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupSecret = function (vaultBaseUrl, secretName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretName: secretName,
            options: options
        }, backupSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreSecret = function (vaultBaseUrl, secretBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            secretBundleBackup: secretBundleBackup,
            options: options
        }, restoreSecretOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateContacts = function (vaultBaseUrl, contacts, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            contacts: contacts,
            options: options
        }, setCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateContacts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, deleteCertificateContactsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuers = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getCertificateIssuersOperationSpec, callback);
    };
    KeyVaultClient.prototype.setCertificateIssuer = function (vaultBaseUrl, issuerName, provider, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            provider: provider,
            options: options
        }, setCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, updateCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, getCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateIssuer = function (vaultBaseUrl, issuerName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            issuerName: issuerName,
            options: options
        }, deleteCertificateIssuerOperationSpec, callback);
    };
    KeyVaultClient.prototype.createCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, createCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.importCertificate = function (vaultBaseUrl, certificateName, base64EncodedCertificate, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            base64EncodedCertificate: base64EncodedCertificate,
            options: options
        }, importCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateVersions = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateVersionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificatePolicy = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificatePolicy = function (vaultBaseUrl, certificateName, certificatePolicy, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificatePolicy: certificatePolicy,
            options: options
        }, updateCertificatePolicyOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, updateCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificate = function (vaultBaseUrl, certificateName, certificateVersion, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            certificateVersion: certificateVersion,
            options: options
        }, getCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateCertificateOperation = function (vaultBaseUrl, certificateName, cancellationRequested, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            cancellationRequested: cancellationRequested,
            options: options
        }, updateCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.getCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteCertificateOperation = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, deleteCertificateOperationOperationSpec, callback);
    };
    KeyVaultClient.prototype.mergeCertificate = function (vaultBaseUrl, certificateName, x509Certificates, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            x509Certificates: x509Certificates,
            options: options
        }, mergeCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, backupCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreCertificate = function (vaultBaseUrl, certificateBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateBundleBackup: certificateBundleBackup,
            options: options
        }, restoreCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificates = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedCertificatesOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, getDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, purgeDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedCertificate = function (vaultBaseUrl, certificateName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            certificateName: certificateName,
            options: options
        }, recoverDeletedCertificateOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccounts = function (vaultBaseUrl, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            options: options
        }, getDeletedStorageAccountsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.purgeDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, purgeDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, recoverDeletedStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.backupStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, backupStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.restoreStorageAccount = function (vaultBaseUrl, storageBundleBackup, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageBundleBackup: storageBundleBackup,
            options: options
        }, restoreStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, deleteStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.getStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.setStorageAccount = function (vaultBaseUrl, storageAccountName, resourceId, activeKeyName, autoRegenerateKey, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            resourceId: resourceId,
            activeKeyName: activeKeyName,
            autoRegenerateKey: autoRegenerateKey,
            options: options
        }, setStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateStorageAccount = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, updateStorageAccountOperationSpec, callback);
    };
    KeyVaultClient.prototype.regenerateStorageAccountKey = function (vaultBaseUrl, storageAccountName, keyName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            keyName: keyName,
            options: options
        }, regenerateStorageAccountKeyOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinitions = function (vaultBaseUrl, storageAccountName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            options: options
        }, getDeletedSasDefinitionsOperationSpec, callback);
    };
    KeyVaultClient.prototype.getDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.recoverDeletedSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, recoverDeletedSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.deleteSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, deleteSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.getSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, getSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.setSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, templateUri, sasType, validityPeriod, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            templateUri: templateUri,
            sasType: sasType,
            validityPeriod: validityPeriod,
            options: options
        }, setSasDefinitionOperationSpec, callback);
    };
    KeyVaultClient.prototype.updateSasDefinition = function (vaultBaseUrl, storageAccountName, sasDefinitionName, options, callback) {
        return this.sendOperationRequest({
            vaultBaseUrl: vaultBaseUrl,
            storageAccountName: storageAccountName,
            sasDefinitionName: sasDefinitionName,
            options: options
        }, updateSasDefinitionOperationSpec, callback);
    };
    return KeyVaultClient;
}(KeyVaultClientContext));
// Operation Specifications
var serializer = new coreHttp.Serializer(Mappers);
var createKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/create",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            kty: "kty",
            keySize: ["options", "keySize"],
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"],
            curve: ["options", "curve"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importKeyOperationSpec = {
    httpMethod: "PUT",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            hsm: ["options", "hsm"],
            key: "key",
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyImportParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "keys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateKeyOperationSpec = {
    httpMethod: "PATCH",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyOps: ["options", "keyOps"],
            keyAttributes: ["options", "keyAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/{key-version}",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeyVersionsOperationSpec = {
    httpMethod: "GET",
    path: "keys/{key-name}/versions",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getKeysOperationSpec = {
    httpMethod: "GET",
    path: "keys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/backup",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupKeyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyBundleBackup: "keyBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var encryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/encrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var decryptOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/decrypt",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var signOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/sign",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeySignParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var verifyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/verify",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            digest: "digest",
            signature: "signature"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyVerifyParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyVerifyResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var wrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/wrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var unwrapKeyOperationSpec = {
    httpMethod: "POST",
    path: "keys/{key-name}/{key-version}/unwrapkey",
    urlParameters: [vaultBaseUrl, keyName1, keyVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            algorithm: "algorithm",
            value: "value"
        },
        mapper: tslib.__assign(tslib.__assign({}, KeyOperationsParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: KeyOperationResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeysOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedKeyOperationSpec = {
    httpMethod: "GET",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedKeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedKeyOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedkeys/{key-name}",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedKeyOperationSpec = {
    httpMethod: "POST",
    path: "deletedkeys/{key-name}/recover",
    urlParameters: [vaultBaseUrl, keyName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: KeyBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSecretOperationSpec = {
    httpMethod: "PUT",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            value: "value",
            tags: ["options", "tags"],
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretSetParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "secrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSecretOperationSpec = {
    httpMethod: "PATCH",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            contentType: ["options", "contentType"],
            secretAttributes: ["options", "secretAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/{secret-version}",
    urlParameters: [vaultBaseUrl, secretName1, secretVersion],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretsOperationSpec = {
    httpMethod: "GET",
    path: "secrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSecretVersionsOperationSpec = {
    httpMethod: "GET",
    path: "secrets/{secret-name}/versions",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretsOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSecretOperationSpec = {
    httpMethod: "GET",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedSecretOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedsecrets/{secret-name}",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSecretOperationSpec = {
    httpMethod: "POST",
    path: "deletedsecrets/{secret-name}/recover",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/{secret-name}/backup",
    urlParameters: [vaultBaseUrl, secretName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupSecretResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreSecretOperationSpec = {
    httpMethod: "POST",
    path: "secrets/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            secretBundleBackup: "secretBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, SecretRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SecretBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "certificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateContactsOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: "contacts",
        mapper: tslib.__assign(tslib.__assign({}, Contacts), { required: true })
    },
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateContactsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateContactsOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/contacts",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuersOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setCertificateIssuerOperationSpec = {
    httpMethod: "PUT",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            provider: "provider",
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateIssuerSetParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateIssuerOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            provider: ["options", "provider"],
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateIssuerUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateIssuerOperationSpec = {
    httpMethod: "GET",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateIssuerOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/issuers/{issuer-name}",
    urlParameters: [vaultBaseUrl, issuerName],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var createCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/create",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateCreateParameters), { required: true })
    },
    responses: {
        202: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var importCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/import",
    urlParameters: [vaultBaseUrl, certificateName1],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            base64EncodedCertificate: "base64EncodedCertificate",
            password: ["options", "password"],
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateImportParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateVersionsOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/versions",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificatePolicyOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificatePolicyOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/policy",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: "certificatePolicy",
        mapper: tslib.__assign(tslib.__assign({}, CertificatePolicy), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/{certificate-version}",
    urlParameters: [
        vaultBaseUrl,
        certificateName0,
        certificateVersion
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateCertificateOperationOperationSpec = {
    httpMethod: "PATCH",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            cancellationRequested: "cancellationRequested"
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateOperationUpdateParameter), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getCertificateOperationOperationSpec = {
    httpMethod: "GET",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteCertificateOperationOperationSpec = {
    httpMethod: "DELETE",
    path: "certificates/{certificate-name}/pending",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var mergeCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/pending/merge",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            x509Certificates: "x509Certificates",
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateMergeParameters), { required: true })
    },
    responses: {
        201: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/{certificate-name}/backup",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupCertificateResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreCertificateOperationSpec = {
    httpMethod: "POST",
    path: "certificates/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            certificateBundleBackup: "certificateBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, CertificateRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificatesOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, includePending, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedCertificateOperationSpec = {
    httpMethod: "GET",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedCertificateOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedcertificates/{certificate-name}",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedCertificateOperationSpec = {
    httpMethod: "POST",
    path: "deletedcertificates/{certificate-name}/recover",
    urlParameters: [vaultBaseUrl, certificateName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "storage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: StorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage",
    urlParameters: [vaultBaseUrl],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var purgeDeletedStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "deletedstorage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/recover",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var backupStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/backup",
    urlParameters: [vaultBaseUrl, storageAccountName1],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: BackupStorageResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var restoreStorageAccountOperationSpec = {
    httpMethod: "POST",
    path: "storage/restore",
    urlParameters: [vaultBaseUrl],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            storageBundleBackup: "storageBundleBackup"
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageRestoreParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteStorageAccountOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedStorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getStorageAccountOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setStorageAccountOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            resourceId: "resourceId",
            activeKeyName: "activeKeyName",
            autoRegenerateKey: "autoRegenerateKey",
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateStorageAccountOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            activeKeyName: ["options", "activeKeyName"],
            autoRegenerateKey: ["options", "autoRegenerateKey"],
            regenerationPeriod: ["options", "regenerationPeriod"],
            storageAccountAttributes: ["options", "storageAccountAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var regenerateStorageAccountKeyOperationSpec = {
    httpMethod: "POST",
    path: "storage/{storage-account-name}/regeneratekey",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            keyName: "keyName"
        },
        mapper: tslib.__assign(tslib.__assign({}, StorageAccountRegenerteKeyParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: StorageBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionsOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas",
    urlParameters: [vaultBaseUrl, storageAccountName0],
    queryParameters: [maxresults, apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getDeletedSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var recoverDeletedSasDefinitionOperationSpec = {
    httpMethod: "POST",
    path: "deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var deleteSasDefinitionOperationSpec = {
    httpMethod: "DELETE",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: DeletedSasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var getSasDefinitionOperationSpec = {
    httpMethod: "GET",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var setSasDefinitionOperationSpec = {
    httpMethod: "PUT",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            templateUri: "templateUri",
            sasType: "sasType",
            validityPeriod: "validityPeriod",
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SasDefinitionCreateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};
var updateSasDefinitionOperationSpec = {
    httpMethod: "PATCH",
    path: "storage/{storage-account-name}/sas/{sas-definition-name}",
    urlParameters: [
        vaultBaseUrl,
        storageAccountName0,
        sasDefinitionName
    ],
    queryParameters: [apiVersion],
    requestBody: {
        parameterPath: {
            templateUri: ["options", "templateUri"],
            sasType: ["options", "sasType"],
            validityPeriod: ["options", "validityPeriod"],
            sasDefinitionAttributes: ["options", "sasDefinitionAttributes"],
            tags: ["options", "tags"]
        },
        mapper: tslib.__assign(tslib.__assign({}, SasDefinitionUpdateParameters), { required: true })
    },
    responses: {
        200: {
            bodyMapper: SasDefinitionBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    serializer: serializer
};

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
var SDK_VERSION = "4.0.2";

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    var tokenCache = new coreHttp.ExpiringAccessTokenCache();
    return {
        create: function (nextPolicy, options) {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache);
        }
    };
}
var AuthenticationChallenge = /** @class */ (function () {
    function AuthenticationChallenge(scopes) {
        this.scopes = scopes;
    }
    return AuthenticationChallenge;
}());
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
var ChallengeBasedAuthenticationPolicy = /** @class */ (function (_super) {
    tslib.__extends(ChallengeBasedAuthenticationPolicy, _super);
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy The next RequestPolicy in the request pipeline.
     * @param options Options for this RequestPolicy.
     * @param credential The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache The cache for the most recent AccessToken returned by the TokenCredential.
     */
    function ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.credential = credential;
        _this.tokenCache = tokenCache;
        _this.challenge = undefined;
        return _this;
    }
    ChallengeBasedAuthenticationPolicy.prototype.parseWWWAuthenticate = function (www_authenticate) {
        // Parses an authentication message like:
        // ```
        // Bearer authorization="some_authorization", resource="https://some.url"
        // ```
        var authenticateArray = www_authenticate.split(" ");
        // Remove the "Bearer" piece
        delete authenticateArray[0];
        // Split the KV comma-separated list
        var commaSep = authenticateArray.join().split(",");
        for (var _i = 0, commaSep_1 = commaSep; _i < commaSep_1.length; _i++) {
            var item = commaSep_1[_i];
            // Split the key/value pairs
            var kv = item.split("=");
            if (kv[0].trim() == "resource") {
                // Remove the quotations around the string
                var resource = kv[1].trim().replace(/['"]+/g, '');
                return resource;
            }
        }
        return "";
    };
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource
     */
    ChallengeBasedAuthenticationPolicy.prototype.sendRequest = function (webResource) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var originalBody, response, www_authenticate, resource, challenge;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!webResource.headers)
                            webResource.headers = new coreHttp.HttpHeaders();
                        originalBody = webResource.body;
                        if (!(this.challenge == undefined)) return [3 /*break*/, 1];
                        // Use a blank to start the challenge
                        webResource.body = "";
                        return [3 /*break*/, 3];
                    case 1: 
                    // or use the cached token if we have one
                    return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 2:
                        // or use the cached token if we have one
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._nextPolicy.sendRequest(webResource)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status == 401)) return [3 /*break*/, 7];
                        webResource.body = originalBody;
                        www_authenticate = response.headers.get("WWW-Authenticate");
                        if (!www_authenticate) return [3 /*break*/, 6];
                        resource = this.parseWWWAuthenticate(www_authenticate);
                        challenge = new AuthenticationChallenge(resource + "/.default");
                        if (!(this.challenge != challenge)) return [3 /*break*/, 6];
                        this.challenge = challenge;
                        this.tokenCache.setCachedToken(undefined);
                        return [4 /*yield*/, this.authenticateRequest(webResource)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];
                    case 7: return [2 /*return*/, response];
                }
            });
        });
    };
    ChallengeBasedAuthenticationPolicy.prototype.authenticateRequest = function (webResource) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var accessToken;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        accessToken = this.tokenCache.getCachedToken();
                        if (!(accessToken === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.credential.getToken(this.challenge.scopes)];
                    case 1:
                        accessToken = (_a.sent()) || undefined;
                        this.tokenCache.setCachedToken(accessToken);
                        _a.label = 2;
                    case 2:
                        if (accessToken) {
                            webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, "Bearer " + accessToken.token);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return ChallengeBasedAuthenticationPolicy;
}(coreHttp.BaseRequestPolicy));

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete secret's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update(options) {
    if (options === void 0) { options = {}; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        var state, name, client, requestOptions, deletedSecret, _a, error_1;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    state = this.state;
                    name = state.name, client = state.client;
                    requestOptions = state.requestOptions || {};
                    if (options.abortSignal) {
                        requestOptions.abortSignal = options.abortSignal;
                    }
                    if (!!state.isStarted) return [3 /*break*/, 2];
                    return [4 /*yield*/, client.deleteSecret(name, requestOptions)];
                case 1:
                    deletedSecret = _b.sent();
                    state.isStarted = true;
                    state.result = deletedSecret;
                    if (!deletedSecret.properties.recoveryId) {
                        state.isCompleted = true;
                    }
                    _b.label = 2;
                case 2:
                    if (!!state.isCompleted) return [3 /*break*/, 6];
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 5, , 6]);
                    _a = state;
                    return [4 /*yield*/, client.getDeletedSecret(name, { requestOptions: requestOptions })];
                case 4:
                    _a.result = _b.sent();
                    state.isCompleted = true;
                    return [3 /*break*/, 6];
                case 5:
                    error_1 = _b.sent();
                    if (error_1.statusCode === 403) {
                        // At this point, the resource exists but the user doesn't have access to it.
                        state.isCompleted = true;
                    }
                    else if (error_1.statusCode !== 404) {
                        state.error = error_1;
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/, makeDeleteSecretPollOperation(state)];
            }
        });
    });
}
/**
 * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel(_) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            throw new Error("Canceling the deletion of a secret is not supported.");
        });
    });
}
/**
 * @summary Serializes the create secret's poll operation
 */
function toString() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create secret's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeDeleteSecretPollOperation(state) {
    return {
        state: tslib.__assign({}, state),
        update: update,
        cancel: cancel,
        toString: toString
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a secret finishes being deleted
 */
var DeleteSecretPoller = /** @class */ (function (_super) {
    tslib.__extends(DeleteSecretPoller, _super);
    function DeleteSecretPoller(options) {
        var _this = this;
        var client = options.client, name = options.name, requestOptions = options.requestOptions, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 2000 : _a, resumeFrom = options.resumeFrom;
        var state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        var operation = makeDeleteSecretPollOperation(tslib.__assign(tslib.__assign({}, state), { name: name,
            requestOptions: requestOptions,
            client: client }));
        _this = _super.call(this, operation) || this;
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof DeleteSecretPoller
     */
    DeleteSecretPoller.prototype.delay = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, coreHttp.delay(this.intervalInMs)];
            });
        });
    };
    return DeleteSecretPoller;
}(coreLro.Poller));

// Copyright (c) Microsoft Corporation.
/**
 * @summary Reaches to the service and updates the delete secret's poll operation.
 * @param [options] The optional parameters, which are an abortSignal from @azure/abort-controller and a function that triggers the poller's onProgress function.
 */
function update$1(options) {
    if (options === void 0) { options = {}; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        var state, name, client, requestOptions, _a, _1, _b, _c, error_1;
        return tslib.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    state = this.state;
                    name = state.name, client = state.client;
                    requestOptions = state.requestOptions || {};
                    if (options.abortSignal) {
                        requestOptions.abortSignal = options.abortSignal;
                    }
                    if (!!state.isStarted) return [3 /*break*/, 6];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 3, , 4]);
                    _a = state;
                    return [4 /*yield*/, client.getSecret(name, { requestOptions: requestOptions })];
                case 2:
                    _a.result = (_d.sent()).properties;
                    state.isCompleted = true;
                    return [3 /*break*/, 4];
                case 3:
                    _1 = _d.sent();
                    return [3 /*break*/, 4];
                case 4:
                    if (!!state.isCompleted) return [3 /*break*/, 6];
                    _b = state;
                    return [4 /*yield*/, client.recoverDeletedSecret(name, { requestOptions: requestOptions })];
                case 5:
                    _b.result = _d.sent();
                    state.isStarted = true;
                    _d.label = 6;
                case 6:
                    if (!!state.isCompleted) return [3 /*break*/, 10];
                    _d.label = 7;
                case 7:
                    _d.trys.push([7, 9, , 10]);
                    _c = state;
                    return [4 /*yield*/, client.getSecret(name, { requestOptions: requestOptions })];
                case 8:
                    _c.result = (_d.sent()).properties;
                    state.isCompleted = true;
                    return [3 /*break*/, 10];
                case 9:
                    error_1 = _d.sent();
                    if (error_1.statusCode === 403) {
                        // At this point, the resource exists but the user doesn't have access to it.
                        state.isCompleted = true;
                    }
                    else if (error_1.statusCode !== 404) {
                        state.error = error_1;
                        state.isCompleted = true;
                    }
                    return [3 /*break*/, 10];
                case 10: return [2 /*return*/, makeRecoverDeletedSecretPollOperation(state)];
            }
        });
    });
}
/**
 * @summary Reaches to the service and cancels the secret's operation, also updating the secret's poll operation
 * @param [options] The optional parameters, which is only an abortSignal from @azure/abort-controller
 */
function cancel$1(_) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            throw new Error("Canceling the deletion of a secret is not supported.");
        });
    });
}
/**
 * @summary Serializes the create secret's poll operation
 */
function toString$1() {
    return JSON.stringify({
        state: this.state
    });
}
/**
 * @summary Builds a create secret's poll operation
 * @param [state] A poll operation's state, in case the new one is intended to follow up where the previous one was left.
 */
function makeRecoverDeletedSecretPollOperation(state) {
    return {
        state: tslib.__assign({}, state),
        update: update$1,
        cancel: cancel$1,
        toString: toString$1
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a secret finishes being deleted
 */
var RecoverDeletedSecretPoller = /** @class */ (function (_super) {
    tslib.__extends(RecoverDeletedSecretPoller, _super);
    function RecoverDeletedSecretPoller(options) {
        var _this = this;
        var client = options.client, name = options.name, requestOptions = options.requestOptions, _a = options.intervalInMs, intervalInMs = _a === void 0 ? 2000 : _a, resumeFrom = options.resumeFrom;
        var state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        var operation = makeRecoverDeletedSecretPollOperation(tslib.__assign(tslib.__assign({}, state), { name: name,
            requestOptions: requestOptions,
            client: client }));
        _this = _super.call(this, operation) || this;
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     * @memberof RecoverDeletedSecretPoller
     */
    RecoverDeletedSecretPoller.prototype.delay = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, coreHttp.delay(this.intervalInMs)];
            });
        });
    };
    return RecoverDeletedSecretPoller;
}(coreLro.Poller));

function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection != "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier != "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    var baseUri;
    try {
        baseUri = url.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Not a valid URI");
    }
    // Path is of the form '/collection/name[/version]'
    var segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". Bad number of segments: " + segments.length);
    }
    if (collection !== segments[1]) {
        throw new Error("Invalid " + collection + " identifier: " + identifier + ". segment [1] should be \"" + collection + "\", found \"" + segments[1] + "\"");
    }
    var vaultUrl = baseUri.protocol + "//" + baseUri.host;
    var name = segments[2];
    var version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl: vaultUrl,
        name: name,
        version: version
    };
}

// Copyright (c) Microsoft Corporation.
// This is part of constructing the autogenerated client. In the future, it should not
// be required. See also: https://github.com/Azure/azure-sdk-for-js/issues/5508
var SERVICE_API_VERSION = "7.0";
/**
 * The SecretClient provides methods to manage {@link KeyVaultSecret} in
 * the Azure Key Vault. The client supports creating, retrieving, updating,
 * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The
 * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure
 * Key Vault.
 */
var SecretClient = /** @class */ (function () {
    /**
     * Creates an instance of SecretClient.
     *
     * Example usage:
     * ```ts
     * import { SecretClient } from "@azure/keyvault-secrets";
     * import { DefaultAzureCredential } from "@azure/identity";
     *
     * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;
     * let credentials = new DefaultAzureCredential();
     *
     * let client = new SecretClient(vaultUrl, credentials);
     * ```
     * @param {string} vaultUrl the base URL to the vault.
     * @param {TokenCredential} credential An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the @azure/identity package to create a credential that suits your needs.
     * @param {PipelineOptions} [pipelineOptions] Optional. Pipeline options used to configure Key Vault API requests.
     *                                                         Omit this parameter to use the default pipeline configuration.
     * @memberof SecretClient
     */
    function SecretClient(vaultUrl, credential, pipelineOptions) {
        if (pipelineOptions === void 0) { pipelineOptions = {}; }
        /**
         * @internal
         * @ignore
         * A self reference that bypasses private methods, for the pollers.
         */
        this.pollerClient = {
            recoverDeletedSecret: this.recoverDeletedSecret.bind(this),
            getSecret: this.getSecret.bind(this),
            deleteSecret: this.deleteSecret.bind(this),
            getDeletedSecret: this.getDeletedSecret.bind(this)
        };
        this.vaultUrl = vaultUrl;
        var libInfo = "azsdk-js-keyvault-secrets/" + SDK_VERSION;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                ? pipelineOptions.userAgentOptions.userAgentPrefix + " " + libInfo
                : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo
            };
        }
        var authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        var internalPipelineOptions = tslib.__assign(tslib.__assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                logPolicyOptions: {
                    allowedHeaderNames: [
                        "x-ms-keyvault-region",
                        "x-ms-keyvault-network-info",
                        "x-ms-keyvault-service-version"
                    ]
                }
            }
        });
        var pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new KeyVaultClient(credential, SERVICE_API_VERSION, pipeline);
    }
    /**
     * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret
     * already exists, Azure Key Vault creates a new version of that secret.
     * This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     * ```
     * @summary Adds a secret in a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} value The value of the secret.
     * @param {SetSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.setSecret = function (secretName, value, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        if (!requestOptions) return [3 /*break*/, 5];
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { secretAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("setSecret", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.setSecret(this.vaultUrl, secretName, value, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                    case 5: return [4 /*yield*/, this.client.setSecret(this.vaultUrl, secretName, value, requestOptions)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * Deletes a secret stored in Azure Key Vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.
     *
     * This operation requires the secrets/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await deletePoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Deletes a secret from a specified key vault.
     * @param {string} secretName The name of the secret.
     * @param {BeginDeleteSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.beginDeleteSecret = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        poller = new DeleteSecretPoller(tslib.__assign(tslib.__assign({ name: name, client: this.pollerClient }, options), { requestOptions: requestOptions }));
                        // This will initialize the poller's operation (the deletion of the secret).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the deletion of the secret).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * The updateSecret method changes specified attributes of an existing stored secret. Properties that
     * are not specified in the request are left unchanged. The value of a secret itself cannot be
     * changed. This operation requires the secrets/set permission.
     *
     * Example usage:
     * ```ts
     * let secretName = "MySecretName";
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret(secretName);
     * await client.updateSecret(secretName, secret.version, { enabled: false });
     * ```
     * @summary Updates the attributes associated with a specified secret in a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {string} secretVersion The version of the secret.
     * @param {UpdateSecretPropertiesOptions} [options] The optional parameters.
     */
    SecretClient.prototype.updateSecretProperties = function (secretName, secretVersion, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, enabled, notBefore, expires, remainingOptions, unflattenedOptions, span, response, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        if (!requestOptions) return [3 /*break*/, 5];
                        enabled = requestOptions.enabled, notBefore = requestOptions.notBefore, expires = requestOptions.expiresOn, remainingOptions = tslib.__rest(requestOptions, ["enabled", "notBefore", "expiresOn"]);
                        unflattenedOptions = tslib.__assign(tslib.__assign({}, remainingOptions), { secretAttributes: {
                                enabled: enabled,
                                notBefore: notBefore,
                                expires: expires
                            } });
                        span = this.createSpan("updateSecretProperties", unflattenedOptions);
                        response = void 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.updateSecret(this.vaultUrl, secretName, secretVersion, this.setParentSpan(span, unflattenedOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                    case 5: return [4 /*yield*/, this.client.updateSecret(this.vaultUrl, secretName, secretVersion, requestOptions)];
                    case 6:
                        response = _a.sent();
                        return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                }
            });
        });
    };
    /**
     * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires
     * the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let secret = await client.getSecret("MySecretName");
     * ```
     * @summary Get a specified secret from a given key vault.
     * @param {string} secretName The name of the secret.
     * @param {GetSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.getSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getSecret(this.vaultUrl, secretName, options && options.version ? options.version : "", this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The getDeletedSecret method returns the specified deleted secret along with its attributes.
     * This operation requires the secrets/get permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * await client.getDeletedSecret("MyDeletedSecret");
     * ```
     * @summary Gets the specified deleted secret.
     * @param {string} secretName The name of the secret.
     * @param {GetDeletedSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.getDeletedSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("getDeletedSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.getDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * The purge deleted secret operation removes the secret permanently, without the possibility of
     * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
     * requires the secrets/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     * await client.purgeDeletedSecret("MySecretName");
     * ```
     * @summary Permanently deletes the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {PurgeDeletedSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.purgeDeletedSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("purgeDeletedSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.purgeDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Recovers the deleted secret in the specified vault.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.
     *
     * This operation requires the secrets/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new SecretClient(url, credentials);
     * await client.setSecret("MySecretName", "ABC123");
     *
     * const deletePoller = await client.beginDeleteSecret("MySecretName");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.recoverDeletedSecret("MySecretName");
     *
     * // Serializing the poller
     * const serialized = recoverPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedSecret("MySecretName", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedSecret = await recoverPoller.pollUntilDone();
     * console.log(deletedSecret);
     * ```
     * @summary Recovers the deleted secret to the latest version.
     * @param {string} secretName The name of the deleted secret.
     * @param {BeginRecoverDeletedSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.beginRecoverDeletedSecret = function (name, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, poller;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        poller = new RecoverDeletedSecretPoller(tslib.__assign(tslib.__assign({ name: name, client: this.pollerClient }, options), { requestOptions: requestOptions }));
                        // This will initialize the poller's operation (the recovery of the deleted secret).
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // This will initialize the poller's operation (the recovery of the deleted secret).
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * Requests that a backup of the specified secret be downloaded to the client. All versions of the
     * secret will be downloaded. This operation requires the secrets/backup permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let backupResult = await client.backupSecret("MySecretName");
     * ```
     * @summary Backs up the specified secret.
     * @param {string} secretName The name of the secret.
     * @param {BackupSecretOptions} [options] The optional parameters.
     */
    SecretClient.prototype.backupSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("backupSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.backupSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, response.value];
                }
            });
        });
    };
    /**
     * Restores a backed up secret, and all its versions, to a vault. This operation requires the
     * secrets/restore permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * let mySecretBundle = await client.backupSecret("MySecretName");
     * // ...
     * await client.restoreSecretBackup(mySecretBundle);
     * ```
     * @summary Restores a backed up secret to a vault.
     * @param {Uint8Array} secretBundleBackup The backup blob associated with a secret bundle.
     * @param {RestoreSecretResponse} [options] The optional parameters.
     */
    SecretClient.prototype.restoreSecretBackup = function (secretBundleBackup, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("restoreSecretBackup", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.restoreSecret(this.vaultUrl, secretBundleBackup, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response).properties];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Sends a delete request for the given KeyVault Secret's name to the KeyVault service.
     * Since the KeyVault Secret won't be immediately deleted, we have {@link beginDeleteSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RequestOptionsBase} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.deleteSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("deleteSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.deleteSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, this.getSecretFromSecretBundle(response)];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Sends a request to recover a deleted KeyVault Secret based on the given name.
     * Since the KeyVault Secret won't be immediately recover the deleted secret, we have {@link beginRecoverDeletedSecret}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {RecoverDeletedKeyOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.recoverDeletedSecret = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var requestOptions, span, properties, response;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
                        span = this.createSpan("recoverDeletedSecret", requestOptions);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, this.client.recoverDeletedSecret(this.vaultUrl, secretName, this.setParentSpan(span, requestOptions))];
                    case 2:
                        response = _a.sent();
                        properties = this.getSecretFromSecretBundle(response).properties;
                        return [3 /*break*/, 4];
                    case 3:
                        span.end();
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/, properties];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listPropertiesOfSecretVersionsPage = function (secretName, continuationState, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfSecretVersionsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getSecretVersions(this.vaultUrl, secretName, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getSecretVersions(continuationState.continuationToken, secretName, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.
     * @param {string} name The name of the KeyVault Secret.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listPropertiesOfSecretVersionsAll = function (secretName, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfSecretVersionsAll_1() {
            var f, _a, _b, page, _i, page_1, item, e_1_1;
            var e_1, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listPropertiesOfSecretVersionsPage(secretName, f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_1 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_1.length)) return [3 /*break*/, 8];
                        item = page_1[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecretVersions("MySecretName")) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret version: ", secret);
     * }
     * ```
     * @param {string} secretName Name of the secret to fetch versions for.
     * @param {ListPropertiesOfSecretVersionsOptions} [options] The optional parameters.
     */
    SecretClient.prototype.listPropertiesOfSecretVersions = function (secretName, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfSecretVersions", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfSecretVersionsAll(secretName, updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfSecretVersionsPage(secretName, settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listPropertiesOfSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listPropertiesOfSecretsPage = function (continuationState, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getSecrets(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getSecrets(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle).properties; }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.
     * @param {ListPropertiesOfSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listPropertiesOfSecretsAll = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listPropertiesOfSecretsAll_1() {
            var f, _a, _b, page, _i, page_2, item, e_2_1;
            var e_2, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listPropertiesOfSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_2 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_2.length)) return [3 /*break*/, 8];
                        item = page_2[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const secretProperties of client.listPropertiesOfSecrets()) {
     *   const secret = await client.getSecret(secretProperties.name);
     *   console.log("secret: ", secret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListPropertiesOfSecretsOptions} [options] The optional parameters.
     */
    SecretClient.prototype.listPropertiesOfSecrets = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listPropertiesOfSecrets", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listPropertiesOfSecretsAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listPropertiesOfSecretsPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Deals with the pagination of {@link listDeletedSecrets}.
     * @param {PageSettings} continuationState An object that indicates the position of the paginated request.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listDeletedSecretsPage = function (continuationState, options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listDeletedSecretsPage_1() {
            var optionsComplete, currentSetResponse, currentSetResponse;
            var _this = this;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(continuationState.continuationToken == null)) return [3 /*break*/, 4];
                        optionsComplete = tslib.__assign({ maxresults: continuationState.maxPageSize }, options);
                        return [4 /*yield*/, tslib.__await(this.client.getDeletedSecrets(this.vaultUrl, optionsComplete))];
                    case 1:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 4];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle); }))];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        if (!continuationState.continuationToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, tslib.__await(this.client.getDeletedSecrets(continuationState.continuationToken, options))];
                    case 5:
                        currentSetResponse = _a.sent();
                        continuationState.continuationToken = currentSetResponse.nextLink;
                        if (!currentSetResponse.value) return [3 /*break*/, 8];
                        return [4 /*yield*/, tslib.__await(currentSetResponse.value.map(function (bundle) { return _this.getSecretFromSecretBundle(bundle); }))];
                    case 6: return [4 /*yield*/, _a.sent()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8: return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 4];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @internal
     * @ignore
     * Deals with the iteration of all the available results of {@link listDeletedSecrets}.
     * @param {ListDeletedSecretsOptions} [options] Optional parameters for the underlying HTTP request.
     */
    SecretClient.prototype.listDeletedSecretsAll = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__asyncGenerator(this, arguments, function listDeletedSecretsAll_1() {
            var f, _a, _b, page, _i, page_3, item, e_3_1;
            var e_3, _c;
            return tslib.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        f = {};
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 10, 11, 16]);
                        _a = tslib.__asyncValues(this.listDeletedSecretsPage(f, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, tslib.__await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 9];
                        page = _b.value;
                        _i = 0, page_3 = page;
                        _d.label = 4;
                    case 4:
                        if (!(_i < page_3.length)) return [3 /*break*/, 8];
                        item = page_3[_i];
                        return [4 /*yield*/, tslib.__await(item)];
                    case 5: return [4 /*yield*/, _d.sent()];
                    case 6:
                        _d.sent();
                        _d.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8: return [3 /*break*/, 2];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_3_1 = _d.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _d.trys.push([11, , 14, 15]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, tslib.__await(_c.call(_a))];
                    case 12:
                        _d.sent();
                        _d.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_3) throw e_3.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided
     * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.
     *
     * Example usage:
     * ```ts
     * let client = new SecretClient(url, credentials);
     * for await (const deletedSecret of client.listDeletedSecrets()) {
     *   const deletedSecret = await client.getSecret(deletedSecret.name);
     *   console.log("deleted secret: ", deletedSecret);
     * }
     * ```
     * @summary List all secrets in the vault.
     * @param {ListDeletedSecretsOptions} [options] The optional parameters.
     */
    SecretClient.prototype.listDeletedSecrets = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
        var span = this.createSpan("listDeletedSecrets", requestOptions);
        var updatedOptions = tslib.__assign(tslib.__assign({}, requestOptions), this.setParentSpan(span, requestOptions));
        var iter = this.listDeletedSecretsAll(updatedOptions);
        span.end();
        return _a = {
                next: function () {
                    return iter.next();
                }
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listDeletedSecretsPage(settings, updatedOptions);
            },
            _a;
    };
    /**
     * @internal
     * @ignore
     * Shapes the exposed {@link KeyVaultSecret} based on either a received secret bundle or deleted secret bundle.
     */
    SecretClient.prototype.getSecretFromSecretBundle = function (bundle) {
        var secretBundle = bundle;
        var deletedSecretBundle = bundle;
        var parsedId = parseKeyvaultIdentifier("secrets", secretBundle.id);
        var attributes = secretBundle.attributes;
        delete secretBundle.attributes;
        var resultObject = {
            value: secretBundle.value,
            name: parsedId.name,
            properties: tslib.__assign(tslib.__assign(tslib.__assign({ vaultUrl: parsedId.vaultUrl, expiresOn: attributes.expires, createdOn: attributes.created, updatedOn: attributes.updated }, secretBundle), parsedId), attributes)
        };
        if (deletedSecretBundle.deletedDate) {
            resultObject.properties.deletedOn = deletedSecretBundle.deletedDate;
            delete resultObject.properties.deletedDate;
        }
        if (attributes) {
            if (attributes.vaultUrl) {
                delete resultObject.properties.vaultUrl;
            }
            if (attributes.expires) {
                delete resultObject.properties.expires;
            }
            if (attributes.created) {
                delete resultObject.properties.created;
            }
            if (attributes.updated) {
                delete resultObject.properties.updated;
            }
        }
        return resultObject;
    };
    /**
     * @internal
     * @ignore
     * Creates a span using the tracer that was set by the user
     * @param {string} methodName The name of the method creating the span.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    SecretClient.prototype.createSpan = function (methodName, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        var tracer = coreTracing.getTracer();
        return tracer.startSpan(methodName, requestOptions && requestOptions.spanOptions);
    };
    /**
     * @internal
     * @ignore
     * Returns updated HTTP options with the given span as the parent of future spans,
     * if applicable.
     * @param {Span} span The span for the current operation.
     * @param {RequestOptionsBase} [options] The options for the underlying HTTP request.
     */
    SecretClient.prototype.setParentSpan = function (span, options) {
        if (options === void 0) { options = {}; }
        if (span.isRecording()) {
            return tslib.__assign(tslib.__assign({}, options), { spanOptions: tslib.__assign(tslib.__assign({}, options.spanOptions), { parent: span }) });
        }
        else {
            return options;
        }
    };
    return SecretClient;
}());

exports.SecretClient = SecretClient;
exports.logger = logger;
//# sourceMappingURL=index.js.map
