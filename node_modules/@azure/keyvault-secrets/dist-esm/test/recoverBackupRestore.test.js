// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { retry } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Secret client - restore secrets and recover backups", function () {
    var secretPrefix = "CRUD" + (env.SECRET_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can recover a deleted secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, getDeletedResult, recoverPoller, secretProperties;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        assert.equal(deletePoller.getResult().name, secretName, "Unexpected secret name in result from deletePoller.getResult().");
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, client.getDeletedSecret(secretName)];
                    case 4:
                        getDeletedResult = _a.sent();
                        assert.equal(getDeletedResult.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, testPollerProperties)];
                    case 5:
                        recoverPoller = _a.sent();
                        return [4 /*yield*/, recoverPoller.pollUntilDone()];
                    case 6:
                        secretProperties = _a.sent();
                        assert.equal(secretProperties.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 7:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can recover a deleted secret (non existing)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, recoverPoller, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, testPollerProperties)];
                    case 2:
                        recoverPoller = _a.sent();
                        return [4 /*yield*/, recoverPoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Secret not found: " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can recover a deleted a secret with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName, deletePoller;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                        case 2:
                            deletePoller = _a.sent();
                            return [4 /*yield*/, deletePoller.pollUntilDone()];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, __assign({ requestOptions: {
                                                        timeout: 1
                                                    } }, testPollerProperties))];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can backup a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.backupSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        if (isNode) {
                            assert.equal(Buffer.isBuffer(result), true, "Unexpected return value from backupKey()");
                        }
                        else {
                            assert.equal(result.constructor, Uint8Array, "Unexpected return value from backupKey()");
                        }
                        assert.ok(result.length > 0, "Unexpected length (" + result.length + ") of buffer from backupSecret()");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can backup a secret (non existing)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.backupSecret(secretName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_2 = _a.sent();
                        error = e_2;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can restore a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, backup, getResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.backupSecret(secretName)];
                    case 2:
                        backup = _a.sent();
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, retry(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, client.restoreSecretBackup(backup)];
                            }); }); })];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 5:
                        getResult = _a.sent();
                        assert.equal(getResult.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can restore a secret (Malformed Backup Bytes)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var backup, error, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        backup = new Uint8Array(4728);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.restoreSecretBackup(backup)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_3 = _a.sent();
                        error = e_3;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Backup blob contains invalid or corrupt version.", "Unexpected error from restoreSecretBackup()");
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can timeout deleting a secret", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName, backup;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, client.backupSecret(secretName)];
                        case 2:
                            backup = _a.sent();
                            return [4 /*yield*/, testClient.flushSecret(secretName)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.restoreSecretBackup(backup, {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
});
//# sourceMappingURL=recoverBackupRestore.test.js.map