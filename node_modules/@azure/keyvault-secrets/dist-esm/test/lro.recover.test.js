// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { PollerStoppedError } from "@azure/core-lro";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Secrets client - Long Running Operations - recoverDelete", function () {
    var secretPrefix = "recover" + (env.CERTIFICATE_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can wait until a secret is recovered", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, poller, secretProperties;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "value")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, testPollerProperties)];
                    case 4:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        // The pending secret properties can be obtained this way:
                        assert.equal(poller.getOperationState().result.name, secretName);
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 5:
                        secretProperties = _a.sent();
                        assert.equal(secretProperties.name, secretName);
                        assert.ok(poller.getOperationState().isCompleted);
                        // The final secret can also be obtained this way:
                        assert.equal(poller.getOperationState().result.name, secretName);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can resume from a stopped poller", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, poller, serialized, resumePoller, secretProperties;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "value")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, testPollerProperties)];
                    case 4:
                        poller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        poller.pollUntilDone().catch(function (e) {
                            assert.ok(e instanceof PollerStoppedError);
                            assert.equal(e.name, "PollerStoppedError");
                            assert.equal(e.message, "This poller is already stopped");
                        });
                        return [4 /*yield*/, poller.poll()];
                    case 5:
                        _a.sent(); // Making sure it has some data
                        poller.stopPolling();
                        assert.ok(poller.isStopped());
                        assert.ok(!poller.getOperationState().isCompleted);
                        serialized = poller.toString();
                        return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, __assign({ resumeFrom: serialized }, testPollerProperties))];
                    case 6:
                        resumePoller = _a.sent();
                        assert.ok(poller.getOperationState().isStarted);
                        return [4 /*yield*/, resumePoller.pollUntilDone()];
                    case 7:
                        secretProperties = _a.sent();
                        assert.equal(secretProperties.name, secretName);
                        assert.ok(resumePoller.getOperationState().isCompleted);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can attempt to recover a deleted secret with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName, deletePoller;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, client.setSecret(secretName, "value")];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                        case 2:
                            deletePoller = _a.sent();
                            return [4 /*yield*/, deletePoller.pollUntilDone()];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.beginRecoverDeletedSecret(secretName, __assign({ requestOptions: { timeout: 1 } }, testPollerProperties))];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
});
//# sourceMappingURL=lro.recover.test.js.map