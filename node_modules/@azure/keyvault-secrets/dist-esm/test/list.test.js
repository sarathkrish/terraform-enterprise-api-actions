// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __asyncValues, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import chai from "chai";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { assertThrowsAbortError } from "./utils/utils.common";
var expect = chai.expect;
describe("Secret client - list secrets in various ways", function () {
    var secretValue = "SECRET_VALUE";
    var secretPrefix = "CRUD" + (env.SECRET_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    // This test is only useful while developing locally
    it.skip("can purge all secrets", function () {
        var e_1, _a, e_2, _b;
        return __awaiter(this, void 0, void 0, function () {
            var _c, _d, secretProperties, e_3, e_1_1, _e, _f, deletedSecret, e_4, e_2_1;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _g.trys.push([0, 8, 9, 14]);
                        _c = __asyncValues(client.listPropertiesOfSecrets());
                        _g.label = 1;
                    case 1: return [4 /*yield*/, _c.next()];
                    case 2:
                        if (!(_d = _g.sent(), !_d.done)) return [3 /*break*/, 7];
                        secretProperties = _d.value;
                        _g.label = 3;
                    case 3:
                        _g.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, testClient.flushSecret(secretProperties.name)];
                    case 4:
                        _g.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _g.sent();
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 1];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _g.trys.push([9, , 12, 13]);
                        if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, _a.call(_c)];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14:
                        _g.trys.push([14, 22, 23, 28]);
                        _e = __asyncValues(client.listDeletedSecrets());
                        _g.label = 15;
                    case 15: return [4 /*yield*/, _e.next()];
                    case 16:
                        if (!(_f = _g.sent(), !_f.done)) return [3 /*break*/, 21];
                        deletedSecret = _f.value;
                        _g.label = 17;
                    case 17:
                        _g.trys.push([17, 19, , 20]);
                        return [4 /*yield*/, testClient.purgeSecret(deletedSecret.name)];
                    case 18:
                        _g.sent();
                        return [3 /*break*/, 20];
                    case 19:
                        e_4 = _g.sent();
                        return [3 /*break*/, 20];
                    case 20: return [3 /*break*/, 15];
                    case 21: return [3 /*break*/, 28];
                    case 22:
                        e_2_1 = _g.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 28];
                    case 23:
                        _g.trys.push([23, , 26, 27]);
                        if (!(_f && !_f.done && (_b = _e.return))) return [3 /*break*/, 25];
                        return [4 /*yield*/, _b.call(_e)];
                    case 24:
                        _g.sent();
                        _g.label = 25;
                    case 25: return [3 /*break*/, 27];
                    case 26:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 27: return [7 /*endfinally*/];
                    case 28: return [2 /*return*/];
                }
            });
        });
    });
    it("can list secret properties", function () {
        var e_5, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_1, name_1, found, _b, _c, secretProperties, e_5_1, _d, secretNames_2, name_2;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_1 = secretNames;
                        _e.label = 1;
                    case 1:
                        if (!(_i < secretNames_1.length)) return [3 /*break*/, 4];
                        name_1 = secretNames_1[_i];
                        return [4 /*yield*/, client.setSecret(name_1, "RSA")];
                    case 2:
                        _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 10, 11, 16]);
                        _b = __asyncValues(client.listPropertiesOfSecrets());
                        _e.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _e.sent(), !_c.done)) return [3 /*break*/, 9];
                        secretProperties = _c.value;
                        // The vault might contain more secrets than the ones we inserted.
                        if (!secretNames.includes(secretProperties.name))
                            return [3 /*break*/, 8];
                        found += 1;
                        _e.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_5_1 = _e.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of secrets found by getSecrets.");
                        _d = 0, secretNames_2 = secretNames;
                        _e.label = 17;
                    case 17:
                        if (!(_d < secretNames_2.length)) return [3 /*break*/, 20];
                        name_2 = secretNames_2[_d];
                        return [4 /*yield*/, testClient.flushSecret(name_2)];
                    case 18:
                        _e.sent();
                        _e.label = 19;
                    case 19:
                        _d++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get secret properties with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listPropertiesOfSecrets({
                                requestOptions: { timeout: 1 }
                            });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can list deleted secrets", function () {
        var e_6, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_3, name_3, _b, secretNames_4, name_4, deletePoller, found, _c, _d, secret, e_6_1, _e, secretNames_5, name_5;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_3 = secretNames;
                        _f.label = 1;
                    case 1:
                        if (!(_i < secretNames_3.length)) return [3 /*break*/, 4];
                        name_3 = secretNames_3[_i];
                        return [4 /*yield*/, client.setSecret(name_3, "RSA")];
                    case 2:
                        _f.sent();
                        _f.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, secretNames_4 = secretNames;
                        _f.label = 5;
                    case 5:
                        if (!(_b < secretNames_4.length)) return [3 /*break*/, 9];
                        name_4 = secretNames_4[_b];
                        return [4 /*yield*/, client.beginDeleteSecret(name_4, testPollerProperties)];
                    case 6:
                        deletePoller = _f.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 7:
                        _f.sent();
                        _f.label = 8;
                    case 8:
                        _b++;
                        return [3 /*break*/, 5];
                    case 9:
                        found = 0;
                        _f.label = 10;
                    case 10:
                        _f.trys.push([10, 15, 16, 21]);
                        _c = __asyncValues(client.listDeletedSecrets());
                        _f.label = 11;
                    case 11: return [4 /*yield*/, _c.next()];
                    case 12:
                        if (!(_d = _f.sent(), !_d.done)) return [3 /*break*/, 14];
                        secret = _d.value;
                        // The vault might contain more secrets than the ones we inserted.
                        if (!secretNames.includes(secret.name))
                            return [3 /*break*/, 13];
                        found += 1;
                        _f.label = 13;
                    case 13: return [3 /*break*/, 11];
                    case 14: return [3 /*break*/, 21];
                    case 15:
                        e_6_1 = _f.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 21];
                    case 16:
                        _f.trys.push([16, , 19, 20]);
                        if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 18];
                        return [4 /*yield*/, _a.call(_c)];
                    case 17:
                        _f.sent();
                        _f.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        if (e_6) throw e_6.error;
                        return [7 /*endfinally*/];
                    case 20: return [7 /*endfinally*/];
                    case 21:
                        assert.equal(found, 2, "Unexpected number of secrets found by getDeletedSecrets.");
                        _e = 0, secretNames_5 = secretNames;
                        _f.label = 22;
                    case 22:
                        if (!(_e < secretNames_5.length)) return [3 /*break*/, 25];
                        name_5 = secretNames_5[_e];
                        return [4 /*yield*/, testClient.purgeSecret(name_5)];
                    case 23:
                        _f.sent();
                        _f.label = 24;
                    case 24:
                        _e++;
                        return [3 /*break*/, 22];
                    case 25: return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get the deleted secrets with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listDeletedSecrets({
                                requestOptions: { timeout: 1 }
                            });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can retrieve all versions of a secret", function () {
        var e_7, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretValues, versions, _i, secretValues_1, v, response, results, _b, _c, secretProperties, version, secret, e_7_1, comp;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValues = [secretValue + "0", secretValue + "1", secretValue + "2"];
                        versions = [];
                        _i = 0, secretValues_1 = secretValues;
                        _d.label = 1;
                    case 1:
                        if (!(_i < secretValues_1.length)) return [3 /*break*/, 4];
                        v = secretValues_1[_i];
                        return [4 /*yield*/, client.setSecret(secretName, v)];
                    case 2:
                        response = _d.sent();
                        versions.push({ version: response.properties.version, value: response.value });
                        _d.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        results = [];
                        _d.label = 5;
                    case 5:
                        _d.trys.push([5, 11, 12, 17]);
                        _b = __asyncValues(client.listPropertiesOfSecretVersions(secretName));
                        _d.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 10];
                        secretProperties = _c.value;
                        version = secretProperties.version;
                        return [4 /*yield*/, client.getSecret(secretName, { version: version })];
                    case 8:
                        secret = _d.sent();
                        results.push({ version: secretProperties.version, value: secret.value });
                        _d.label = 9;
                    case 9: return [3 /*break*/, 6];
                    case 10: return [3 /*break*/, 17];
                    case 11:
                        e_7_1 = _d.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 17];
                    case 12:
                        _d.trys.push([12, , 15, 16]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 14];
                        return [4 /*yield*/, _a.call(_b)];
                    case 13:
                        _d.sent();
                        _d.label = 14;
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        if (e_7) throw e_7.error;
                        return [7 /*endfinally*/];
                    case 16: return [7 /*endfinally*/];
                    case 17:
                        comp = function (a, b) {
                            return (a.version + a.value).localeCompare(b.version + b.value);
                        };
                        results.sort(comp);
                        versions.sort(comp);
                        expect(results).to.deep.equal(versions);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 18:
                        _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can get versions of a secret with requestOptions timeout", function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            iter = client.listPropertiesOfSecretVersions("doesntmatter", {
                                requestOptions: { timeout: 1 }
                            });
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, iter.next()];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can list secret versions (non existing)", function () {
        var e_8, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, totalVersions, _b, _c, secretProperties, e_8_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = __asyncValues(client.listPropertiesOfSecretVersions(secretName));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        secretProperties = _c.value;
                        assert.equal(secretProperties.name, secretName, "Unexpected key name in result from listKeyVersions().");
                        totalVersions += 1;
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_8_1 = _d.sent();
                        e_8 = { error: e_8_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_8) throw e_8.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for secret " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can list secrets by page", function () {
        var e_9, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_6, name_6, found, _b, _c, page, _d, page_1, secretProperties, e_9_1, _e, secretNames_7, name_7;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_6 = secretNames;
                        _f.label = 1;
                    case 1:
                        if (!(_i < secretNames_6.length)) return [3 /*break*/, 4];
                        name_6 = secretNames_6[_i];
                        return [4 /*yield*/, client.setSecret(name_6, "RSA")];
                    case 2:
                        _f.sent();
                        _f.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        found = 0;
                        _f.label = 5;
                    case 5:
                        _f.trys.push([5, 10, 11, 16]);
                        _b = __asyncValues(client.listPropertiesOfSecrets().byPage());
                        _f.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 9];
                        page = _c.value;
                        for (_d = 0, page_1 = page; _d < page_1.length; _d++) {
                            secretProperties = page_1[_d];
                            // The vault might contain more secrets than the ones we inserted.
                            if (!secretNames.includes(secretProperties.name))
                                continue;
                            found += 1;
                        }
                        _f.label = 8;
                    case 8: return [3 /*break*/, 6];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_9_1 = _f.sent();
                        e_9 = { error: e_9_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _f.trys.push([11, , 14, 15]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _a.call(_b)];
                    case 12:
                        _f.sent();
                        _f.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_9) throw e_9.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16:
                        assert.equal(found, 2, "Unexpected number of secrets found by getSecrets.");
                        _e = 0, secretNames_7 = secretNames;
                        _f.label = 17;
                    case 17:
                        if (!(_e < secretNames_7.length)) return [3 /*break*/, 20];
                        name_7 = secretNames_7[_e];
                        return [4 /*yield*/, testClient.flushSecret(name_7)];
                    case 18:
                        _f.sent();
                        _f.label = 19;
                    case 19:
                        _e++;
                        return [3 /*break*/, 17];
                    case 20: return [2 /*return*/];
                }
            });
        });
    });
    it("can list deleted secrets by page", function () {
        var e_10, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretNames, _i, secretNames_8, name_8, _b, secretNames_9, name_9, deletePoller, found, _c, _d, page, _e, page_2, secret, e_10_1, _f, secretNames_10, name_10;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretNames = [secretName + "0", secretName + "1"];
                        _i = 0, secretNames_8 = secretNames;
                        _g.label = 1;
                    case 1:
                        if (!(_i < secretNames_8.length)) return [3 /*break*/, 4];
                        name_8 = secretNames_8[_i];
                        return [4 /*yield*/, client.setSecret(name_8, "RSA")];
                    case 2:
                        _g.sent();
                        _g.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        _b = 0, secretNames_9 = secretNames;
                        _g.label = 5;
                    case 5:
                        if (!(_b < secretNames_9.length)) return [3 /*break*/, 9];
                        name_9 = secretNames_9[_b];
                        return [4 /*yield*/, client.beginDeleteSecret(name_9, testPollerProperties)];
                    case 6:
                        deletePoller = _g.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 7:
                        _g.sent();
                        _g.label = 8;
                    case 8:
                        _b++;
                        return [3 /*break*/, 5];
                    case 9:
                        found = 0;
                        _g.label = 10;
                    case 10:
                        _g.trys.push([10, 15, 16, 21]);
                        _c = __asyncValues(client.listDeletedSecrets().byPage());
                        _g.label = 11;
                    case 11: return [4 /*yield*/, _c.next()];
                    case 12:
                        if (!(_d = _g.sent(), !_d.done)) return [3 /*break*/, 14];
                        page = _d.value;
                        for (_e = 0, page_2 = page; _e < page_2.length; _e++) {
                            secret = page_2[_e];
                            // The vault might contain more secrets than the ones we inserted.
                            if (!secretNames.includes(secret.name))
                                continue;
                            found += 1;
                        }
                        _g.label = 13;
                    case 13: return [3 /*break*/, 11];
                    case 14: return [3 /*break*/, 21];
                    case 15:
                        e_10_1 = _g.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 21];
                    case 16:
                        _g.trys.push([16, , 19, 20]);
                        if (!(_d && !_d.done && (_a = _c.return))) return [3 /*break*/, 18];
                        return [4 /*yield*/, _a.call(_c)];
                    case 17:
                        _g.sent();
                        _g.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 20: return [7 /*endfinally*/];
                    case 21:
                        assert.equal(found, 2, "Unexpected number of secrets found by getDeletedSecrets.");
                        _f = 0, secretNames_10 = secretNames;
                        _g.label = 22;
                    case 22:
                        if (!(_f < secretNames_10.length)) return [3 /*break*/, 25];
                        name_10 = secretNames_10[_f];
                        return [4 /*yield*/, testClient.purgeSecret(name_10)];
                    case 23:
                        _g.sent();
                        _g.label = 24;
                    case 24:
                        _f++;
                        return [3 /*break*/, 22];
                    case 25: return [2 /*return*/];
                }
            });
        });
    });
    it("can retrieve all versions of a secret by page", function () {
        var e_11, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretValues, versions, _i, secretValues_2, v, response, results, _b, _c, page, _d, page_3, secretProperties, version, secret, e_11_1, comp;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValues = [secretValue + "0", secretValue + "1", secretValue + "2"];
                        versions = [];
                        _i = 0, secretValues_2 = secretValues;
                        _e.label = 1;
                    case 1:
                        if (!(_i < secretValues_2.length)) return [3 /*break*/, 4];
                        v = secretValues_2[_i];
                        return [4 /*yield*/, client.setSecret(secretName, v)];
                    case 2:
                        response = _e.sent();
                        versions.push({ version: response.properties.version, value: response.value });
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        results = [];
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 13, 14, 19]);
                        _b = __asyncValues(client.listPropertiesOfSecretVersions(secretName).byPage());
                        _e.label = 6;
                    case 6: return [4 /*yield*/, _b.next()];
                    case 7:
                        if (!(_c = _e.sent(), !_c.done)) return [3 /*break*/, 12];
                        page = _c.value;
                        _d = 0, page_3 = page;
                        _e.label = 8;
                    case 8:
                        if (!(_d < page_3.length)) return [3 /*break*/, 11];
                        secretProperties = page_3[_d];
                        version = secretProperties.version;
                        return [4 /*yield*/, client.getSecret(secretName, { version: version })];
                    case 9:
                        secret = _e.sent();
                        results.push({ version: version, value: secret.value });
                        _e.label = 10;
                    case 10:
                        _d++;
                        return [3 /*break*/, 8];
                    case 11: return [3 /*break*/, 6];
                    case 12: return [3 /*break*/, 19];
                    case 13:
                        e_11_1 = _e.sent();
                        e_11 = { error: e_11_1 };
                        return [3 /*break*/, 19];
                    case 14:
                        _e.trys.push([14, , 17, 18]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 16];
                        return [4 /*yield*/, _a.call(_b)];
                    case 15:
                        _e.sent();
                        _e.label = 16;
                    case 16: return [3 /*break*/, 18];
                    case 17:
                        if (e_11) throw e_11.error;
                        return [7 /*endfinally*/];
                    case 18: return [7 /*endfinally*/];
                    case 19:
                        comp = function (a, b) {
                            return (a.version + a.value).localeCompare(b.version + b.value);
                        };
                        results.sort(comp);
                        versions.sort(comp);
                        expect(results).to.deep.equal(versions);
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 20:
                        _e.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can list secret versions by page (non existing)", function () {
        var e_12, _a;
        return __awaiter(this, void 0, void 0, function () {
            var secretName, totalVersions, _b, _c, page, _i, page_4, secretProperties, e_12_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        totalVersions = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 12]);
                        _b = __asyncValues(client.listPropertiesOfSecretVersions(secretName).byPage());
                        _d.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _d.sent(), !_c.done)) return [3 /*break*/, 5];
                        page = _c.value;
                        for (_i = 0, page_4 = page; _i < page_4.length; _i++) {
                            secretProperties = page_4[_i];
                            assert.equal(secretProperties.name, secretName, "Unexpected key name in result from listKeyVersions().");
                            totalVersions += 1;
                        }
                        _d.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_12_1 = _d.sent();
                        e_12 = { error: e_12_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _d.trys.push([7, , 10, 11]);
                        if (!(_c && !_c.done && (_a = _b.return))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(_b)];
                    case 8:
                        _d.sent();
                        _d.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_12) throw e_12.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12:
                        assert.equal(totalVersions, 0, "Unexpected total versions for secret " + secretName);
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=list.test.js.map