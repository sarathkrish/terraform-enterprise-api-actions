// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __assign, __awaiter, __generator } from "tslib";
import * as assert from "assert";
import { isNode } from "@azure/core-http";
import { isPlayingBack, testPollerProperties } from "./utils/recorderUtils";
import { env } from "@azure/test-utils-recorder";
import { authenticate } from "./utils/testAuthentication";
import { AbortController } from "@azure/abort-controller";
import { assertThrowsAbortError } from "./utils/utils.common";
describe("Secret client - create, read, update and delete operations", function () {
    var secretValue = "SECRET_VALUE";
    var secretPrefix = "CRUD" + (env.SECRET_NAME || "SecretName");
    var secretSuffix;
    var client;
    var testClient;
    var recorder;
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            var authentication;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authenticate(this)];
                    case 1:
                        authentication = _a.sent();
                        secretSuffix = authentication.secretSuffix;
                        client = authentication.client;
                        testClient = authentication.testClient;
                        recorder = authentication.recorder;
                        return [2 /*return*/];
                }
            });
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                recorder.stop();
                return [2 /*return*/];
            });
        });
    });
    // The tests follow
    it("can add a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    // If this test is not skipped in the browser's playback, no other test will be played back.
    // This is a bug related to the browser features of the recorder.
    it("can abort adding a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, controller;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!isNode && isPlayingBack) {
                            recorder.skip();
                        }
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        controller = new AbortController();
                        controller.abort();
                        return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                                abortSignal: controller.signal
                                            })];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can timeout adding a secret", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("cannot create a secret with an empty name", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = "";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "\"secretName\" with value \"\" should satisfy the constraint \"Pattern\": /^[0-9a-zA-Z-]+$/.", "Unexpected error while running setSecret with an empty string as the name.");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can set a secret with Empty Value", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, secretValue, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        secretValue = "";
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can set a secret with attributes", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, { expiresOn: expiryDate })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        updated = _a.sent();
                        assert.equal(expiryDate.getDate(), updated.properties.expiresOn.getDate(), "Expect attribute 'expiresOn' to be defined.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can update a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.updateSecretProperties(secretName, "", {
                                expiresOn: expiryDate
                            })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 3:
                        updated = _a.sent();
                        assert.equal(updated.properties.expiresOn.getDate(), expiryDate.getDate(), "Expect attribute 'expiresOn' to be updated.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can timeout updating a secret", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName, expiryDate;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            expiryDate = new Date("3000-01-01");
                            expiryDate.setMilliseconds(0);
                            return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.updateSecretProperties(secretName, "", {
                                                    expiresOn: expiryDate,
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can update a disabled secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, updatedProperties;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                enabled: false
                            })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.updateSecretProperties(secretName, "", {
                                expiresOn: expiryDate
                            })];
                    case 2:
                        updatedProperties = _a.sent();
                        assert.equal(updatedProperties.expiresOn.getDate(), expiryDate.getDate(), "Expect attribute 'expiresOn' to be updated.");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can timeout getting a secret", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.getSecret(secretName, {
                                                    requestOptions: {
                                                        timeout: 1
                                                    }
                                                })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can't get a disabled secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, expiryDate, error, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        expiryDate = new Date("3000-01-01");
                        expiryDate.setMilliseconds(0);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue, {
                                enabled: false
                            })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_2 = _a.sent();
                        error = e_2;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Operation get is not allowed on a disabled secret.", "Unexpected error after trying to get a disabled secret");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 6:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can retrieve the latest version of a secret value", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        result = _a.sent();
                        assert.equal(result.name, secretName, "Unexpected secret name in result from setSecret().");
                        assert.equal(result.value, secretValue, "Unexpected secret value in result from setSecret().");
                        return [4 /*yield*/, testClient.flushSecret(secretName)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a secret (Non Existing)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_3 = _a.sent();
                        error = e_3;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected error after trying to get a disabled secret");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can delete a secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, deletedSecret, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        deletedSecret = deletePoller.getResult();
                        assert.equal(typeof deletedSecret.properties.recoveryId, "string");
                        assert.ok(deletedSecret.properties.deletedOn instanceof Date);
                        assert.ok(deletedSecret.properties.scheduledPurgeDate instanceof Date);
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        deletedSecret = _a.sent();
                        assert.equal(typeof deletedSecret.properties.recoveryId, "string");
                        assert.ok(deletedSecret.properties.deletedOn instanceof Date);
                        assert.ok(deletedSecret.properties.scheduledPurgeDate instanceof Date);
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, client.getSecret(secretName)];
                    case 5:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 6:
                        e_4 = _a.sent();
                        if (e_4.statusCode === 404) {
                            assert.equal(e_4.message, "Secret not found: " + secretName);
                        }
                        else {
                            throw e_4;
                        }
                        return [3 /*break*/, 7];
                    case 7: return [4 /*yield*/, testClient.purgeSecret(secretName)];
                    case 8:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode && !isPlayingBack) {
        // On playback mode, the tests happen too fast for the timeout to work
        it("can timeout deleting a secret", function () {
            return __awaiter(this, void 0, void 0, function () {
                var secretName;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                            return [4 /*yield*/, client.setSecret(secretName, secretValue)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, assertThrowsAbortError(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, client.beginDeleteSecret(secretName, __assign({ requestOptions: {
                                                        timeout: 1
                                                    } }, testPollerProperties))];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can delete a secret (Non Existing)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, e_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 3:
                        e_5 = _a.sent();
                        error = e_5;
                        return [3 /*break*/, 4];
                    case 4:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected error after trying to get a disabled secret");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a deleted secret", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, deletePoller, deletedSecret, getResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        return [4 /*yield*/, client.setSecret(secretName, "RSA")];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        deletedSecret = deletePoller.getResult();
                        assert.equal(deletedSecret.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        deletedSecret = deletePoller.getResult();
                        assert.equal(deletedSecret.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, client.getDeletedSecret(secretName)];
                    case 4:
                        getResult = _a.sent();
                        assert.equal(getResult.name, secretName, "Unexpected secret name in result from getSecret().");
                        return [4 /*yield*/, testClient.purgeSecret(secretName)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can get a deleted secret (Non Existing)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var secretName, error, deletePoller, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        secretName = testClient.formatName(secretPrefix + "-" + this.test.title + "-" + secretSuffix);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, client.beginDeleteSecret(secretName, testPollerProperties)];
                    case 2:
                        deletePoller = _a.sent();
                        return [4 /*yield*/, deletePoller.pollUntilDone()];
                    case 3:
                        _a.sent();
                        throw Error("Expecting an error but not catching one.");
                    case 4:
                        e_6 = _a.sent();
                        error = e_6;
                        return [3 /*break*/, 5];
                    case 5:
                        assert.equal(error.message, "Secret not found: " + secretName, "Unexpected secret name in result from getKey().");
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=CRUD.test.js.map