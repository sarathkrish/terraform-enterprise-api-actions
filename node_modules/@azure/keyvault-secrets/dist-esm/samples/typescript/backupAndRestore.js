"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var src_1 = require("../../src");
var fs = tslib_1.__importStar(require("fs"));
var identity_1 = require("@azure/identity");
function writeFile(filename, text) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(filename, text, function (err) {
            if (err)
                reject(err);
            else
                resolve();
        });
    });
}
function readFile(filename) {
    return new Promise(function (resolve, reject) {
        fs.readFile(filename, function (err, data) {
            if (err)
                reject(err);
            else
                resolve(data);
        });
    });
}
function delay(t, value) {
    return new Promise(function (resolve) { return setTimeout(function () { return resolve(value); }, t); });
}
exports.delay = delay;
function main() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var credential, vaultName, url, client, secretName, backupResult, deletePoller, backupContents, result;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    credential = new identity_1.DefaultAzureCredential();
                    vaultName = process.env["KEYVAULT_NAME"] || "<keyvault-name>";
                    url = "https://" + vaultName + ".vault.azure.net";
                    client = new src_1.SecretClient(url, credential);
                    secretName = "StorageAccountPassword";
                    // Create our secret
                    return [4 /*yield*/, client.setSecret(secretName, "XYZ789")];
                case 1:
                    // Create our secret
                    _a.sent();
                    return [4 /*yield*/, client.backupSecret(secretName)];
                case 2:
                    backupResult = _a.sent();
                    // Write the backup to a file
                    return [4 /*yield*/, writeFile("secret_backup.dat", backupResult)];
                case 3:
                    // Write the backup to a file
                    _a.sent();
                    // Delete the secret
                    console.log("about to delete");
                    return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                case 4:
                    deletePoller = _a.sent();
                    return [4 /*yield*/, deletePoller.pollUntilDone()];
                case 5:
                    _a.sent();
                    // Purge the deleted secret
                    console.log("about to purge");
                    return [4 /*yield*/, client.purgeDeletedSecret(secretName)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, delay(30000)];
                case 7:
                    _a.sent();
                    // Read our backup from a file
                    console.log("about to restore secret");
                    return [4 /*yield*/, readFile("secret_backup.dat")];
                case 8:
                    backupContents = _a.sent();
                    return [4 /*yield*/, client.restoreSecretBackup(backupContents)];
                case 9:
                    result = _a.sent();
                    console.log("Restored secret: ", result);
                    // If we don't want to purge the secret later, we don't need to wait until this finishes
                    return [4 /*yield*/, client.beginDeleteSecret(secretName)];
                case 10:
                    // If we don't want to purge the secret later, we don't need to wait until this finishes
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
main().catch(function (err) {
    console.log("error code: ", err.code);
    console.log("error message: ", err.message);
    console.log("error stack: ", err.stack);
});
//# sourceMappingURL=backupAndRestore.js.map